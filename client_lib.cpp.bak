#include "client_lib.hpp"
#include "communicate.hpp"

int loop_client_fork(const Options &opt, int kOptNum) {
    pid_t pid;
    // cur_num: current children process num
    unsigned int cur_num = 0, conn_num = 0;
    int rtr;    // return value
    fd_set rfds, wfds;

    while(1) {
        while((rtr = check_child()) == 1) {
            cur_num--;
        }
        if(cur_num < kMaxActiveConnections && conn_num < kOptNum) {

            pid = fork();
            if(pid == -1) {
                graceful("loop_client_fork fork", -20);
            } else if(pid == 0) {
                // child
                rtr = client_communicate(opt);
                //error handling: close socketfd and reconnect
                if(rtr < 0) {
                    close(socketfd);
                    // TODO: reconnecting until succeed
                    cerr << "TODO: reconnecting until succeed\n";
                    // while(!client_reconnected(opt));
                }
                //rtr = 1, stage done
                exit(0);
            }
            // parent
            else {
                cur_num ++;
                conn_num ++;
            }
        } else if(conn_num >= kOptNum) {
            // all connection finished
            break;
        } else {
            // reach max_active_connections
            continue;
        }
    }
    return 0;
}

int check_child() {
    errno = 0;
    //set option = WNOHANG to avoid blocking in waitpid()
    //waitpid would return immediately if no exit child
    pid_t pid = waitpid(-1, NULL, WNOHANG);
    if(pid == -1) {
        //ECHILD: no child process
        if(errno == ECHILD) {
            return 0;
            graceful("check_SIGCHLD waitpid", -1);
        }
    } else if(pid == 0) {
        //no exit child
        return 0;
    } else if(pid > 0) {
        //found exit child
        return 1;
    }
    return 2;
}

int create_connection(const Options &opt) {
    // create a connection from opt
    // return negative code on error, socketfd on success

    struct sockaddr_in   servaddr;
    memset(&servaddr, 0, sizeof(servaddr));
    servaddr.sin_family = AF_INET;
    servaddr.sin_port = htons(stoi(opt.at("端口号")));
    if(inet_pton(AF_INET, opt.at("服务器IP地址").c_str(), &servaddr.sin_addr) < 0)
        graceful_return("Invalid ip address", -1);

    // get a socket
    int sockfd = socket(AF_INET, SOCK_STREAM, 0);
    if(sockfd < 0)
        graceful_return("socket", -2);

    // connect blocking
    if(connect(sockfd, (struct sockaddr*)&servaddr, sizeof(servaddr)) == -1) {
        graceful_return("connect", -3);
    }
    return sockfd;
}
